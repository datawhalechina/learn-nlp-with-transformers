## å‰è¨€
æ¥ç€ä¸Šä¸€å°èŠ‚ï¼Œæˆ‘ä»¬å¯¹Huggingfaceå¼€æºä»£ç åº“ä¸­çš„Bertæ¨¡å‹è¿›è¡Œäº†æ·±å…¥å­¦ä¹ ï¼Œè¿™ä¸€èŠ‚æˆ‘ä»¬å¯¹å¦‚ä½•åº”ç”¨BERTè¿›è¡Œè¯¦ç»†çš„è®²è§£ã€‚

æ¶‰åŠåˆ°çš„jupyterå¯ä»¥åœ¨[ä»£ç åº“ï¼šç¯‡ç« 3-ç¼–å†™ä¸€ä¸ªTransformeræ¨¡å‹ï¼šBERTï¼Œä¸‹è½½](https://github.com/datawhalechina/learn-nlp-with-transformers/tree/main/docs/%E7%AF%87%E7%AB%A03-%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AATransformer%E6%A8%A1%E5%9E%8B%EF%BC%9ABERT)

æœ¬æ–‡åŸºäº Transformers ç‰ˆæœ¬ 4.4.2ï¼ˆ2021 å¹´ 3 æœˆ 19 æ—¥å‘å¸ƒï¼‰é¡¹ç›®ä¸­ï¼Œpytorch ç‰ˆçš„ BERT ç›¸å…³ä»£ç ï¼Œä»ä»£ç ç»“æ„ã€å…·ä½“å®ç°ä¸åŸç†ï¼Œä»¥åŠä½¿ç”¨çš„è§’åº¦è¿›è¡Œåˆ†æï¼ŒåŒ…å«ä»¥ä¸‹å†…å®¹ï¼š

3. BERT-based Modelsåº”ç”¨æ¨¡å‹
4. BERTè®­ç»ƒå’Œä¼˜åŒ–
5. Bertè§£å†³NLPä»»åŠ¡
  - BertForSequenceClassification
  - BertForMultiChoice
  - BertForTokenClassification
  - BertForQuestionAnswering
6. BERTè®­ç»ƒä¸ä¼˜åŒ–
7. Pre-Training
  - Fine-Tuning
  - AdamW
  - Warmup

## 3-BERT-based Models
åŸºäº BERT çš„æ¨¡å‹éƒ½å†™åœ¨/models/bert/modeling_bert.pyé‡Œé¢ï¼ŒåŒ…æ‹¬ BERT é¢„è®­ç»ƒæ¨¡å‹å’Œ BERT åˆ†ç±»ç­‰æ¨¡å‹ã€‚

é¦–å…ˆï¼Œä»¥ä¸‹æ‰€æœ‰çš„æ¨¡å‹éƒ½æ˜¯åŸºäº`BertPreTrainedModel`è¿™ä¸€æŠ½è±¡åŸºç±»çš„ï¼Œè€Œåè€…åˆ™åŸºäºä¸€ä¸ªæ›´å¤§çš„åŸºç±»`PreTrainedModel`ã€‚è¿™é‡Œæˆ‘ä»¬å…³æ³¨`BertPreTrainedModel`çš„åŠŸèƒ½ï¼š

ç”¨äºåˆå§‹åŒ–æ¨¡å‹æƒé‡ï¼ŒåŒæ—¶ç»´æŠ¤ç»§æ‰¿è‡ª`PreTrainedModel`çš„ä¸€äº›æ ‡è®°èº«ä»½æˆ–è€…åŠ è½½æ¨¡å‹æ—¶çš„ç±»å˜é‡ã€‚
ä¸‹é¢ï¼Œé¦–å…ˆä»é¢„è®­ç»ƒæ¨¡å‹å¼€å§‹åˆ†æã€‚

*** 
### 3.1 BertForPreTraining

ä¼—æ‰€å‘¨çŸ¥ï¼ŒBERT é¢„è®­ç»ƒä»»åŠ¡åŒ…æ‹¬ä¸¤ä¸ªï¼š

- Masked Language Modelï¼ˆMLMï¼‰ï¼šåœ¨å¥å­ä¸­éšæœºç”¨`[MASK]`æ›¿æ¢ä¸€éƒ¨åˆ†å•è¯ï¼Œç„¶åå°†å¥å­ä¼ å…¥ BERT ä¸­ç¼–ç æ¯ä¸€ä¸ªå•è¯çš„ä¿¡æ¯ï¼Œæœ€ç»ˆç”¨`[MASK]`çš„ç¼–ç ä¿¡æ¯é¢„æµ‹è¯¥ä½ç½®çš„æ­£ç¡®å•è¯ï¼Œè¿™ä¸€ä»»åŠ¡æ—¨åœ¨è®­ç»ƒæ¨¡å‹æ ¹æ®ä¸Šä¸‹æ–‡ç†è§£å•è¯çš„æ„æ€ï¼›
- Next Sentence Predictionï¼ˆNSPï¼‰ï¼šå°†å¥å­å¯¹ A å’Œ B è¾“å…¥ BERTï¼Œä½¿ç”¨`[CLS]`çš„ç¼–ç ä¿¡æ¯è¿›è¡Œé¢„æµ‹ B æ˜¯å¦ A çš„ä¸‹ä¸€å¥ï¼Œè¿™ä¸€ä»»åŠ¡æ—¨åœ¨è®­ç»ƒæ¨¡å‹ç†è§£é¢„æµ‹å¥å­é—´çš„å…³ç³»ã€‚


![å›¾Berté¢„è®­ç»ƒ](./pictures/3-3-bert-lm.png) å›¾Berté¢„è®­ç»ƒ

è€Œå¯¹åº”åˆ°ä»£ç ä¸­ï¼Œè¿™ä¸€èåˆä¸¤ä¸ªä»»åŠ¡çš„æ¨¡å‹å°±æ˜¯BertForPreTrainingï¼Œå…¶ä¸­åŒ…å«ä¸¤ä¸ªç»„ä»¶ï¼š
```
class BertForPreTraining(BertPreTrainedModel):
    def __init__(self, config):
        super().__init__(config)

        self.bert = BertModel(config)
        self.cls = BertPreTrainingHeads(config)

        self.init_weights()
    # ...
```
è¿™é‡Œçš„BertModelåœ¨ä¸Šä¸€ç« èŠ‚ä¸­å·²ç»è¯¦ç»†ä»‹ç»äº†ï¼ˆæ³¨æ„ï¼Œè¿™é‡Œè®¾ç½®çš„æ˜¯é»˜è®¤`add_pooling_layer=True`ï¼Œå³ä¼šæå–`[CLS]`å¯¹åº”çš„è¾“å‡ºç”¨äº NSP ä»»åŠ¡ï¼‰ï¼Œè€Œ`BertPreTrainingHeads`åˆ™æ˜¯è´Ÿè´£ä¸¤ä¸ªä»»åŠ¡çš„é¢„æµ‹æ¨¡å—ï¼š
```
class BertPreTrainingHeads(nn.Module):
    def __init__(self, config):
        super().__init__()
        self.predictions = BertLMPredictionHead(config)
        self.seq_relationship = nn.Linear(config.hidden_size, 2)

    def forward(self, sequence_output, pooled_output):
        prediction_scores = self.predictions(sequence_output)
        seq_relationship_score = self.seq_relationship(pooled_output)
        return prediction_scores, seq_relationship_score 
```
åˆæ˜¯ä¸€å±‚å°è£…ï¼š`BertPreTrainingHeads`åŒ…è£¹äº†`BertLMPredictionHead` å’Œä¸€ä¸ªä»£è¡¨ NSP ä»»åŠ¡çš„çº¿æ€§å±‚ã€‚è¿™é‡Œä¸æŠŠ NSP å¯¹åº”çš„ä»»åŠ¡ä¹Ÿå°è£…ä¸€ä¸ª`BertXXXPredictionHead`ã€‚

**å…¶å®æ˜¯æœ‰å°è£…è¿™ä¸ªç±»çš„ï¼Œä¸è¿‡å®ƒå«åšBertOnlyNSPHeadï¼Œåœ¨è¿™é‡Œç”¨ä¸ä¸Š**

ç»§ç»­ä¸‹æ¢`BertPreTrainingHeads`ï¼š
```
class BertLMPredictionHead(nn.Module):
    def __init__(self, config):
        super().__init__()
        self.transform = BertPredictionHeadTransform(config)

        # The output weights are the same as the input embeddings, but there is
        # an output-only bias for each token.
        self.decoder = nn.Linear(config.hidden_size, config.vocab_size, bias=False)

        self.bias = nn.Parameter(torch.zeros(config.vocab_size))

        # Need a link between the two variables so that the bias is correctly resized with `resize_token_embeddings`
        self.decoder.bias = self.bias

    def forward(self, hidden_states):
        hidden_states = self.transform(hidden_states)
        hidden_states = self.decoder(hidden_states)
        return hidden_states
```

è¿™ä¸ªç±»ç”¨äºé¢„æµ‹`[MASK]`ä½ç½®çš„è¾“å‡ºåœ¨æ¯ä¸ªè¯ä½œä¸ºç±»åˆ«çš„åˆ†ç±»è¾“å‡ºï¼Œæ³¨æ„åˆ°ï¼š

- è¯¥ç±»é‡æ–°åˆå§‹åŒ–äº†ä¸€ä¸ªå…¨ 0 å‘é‡ä½œä¸ºé¢„æµ‹æƒé‡çš„ biasï¼›
- è¯¥ç±»çš„è¾“å‡ºå½¢çŠ¶ä¸º[batch_size, seq_length, vocab_size]ï¼Œå³é¢„æµ‹æ¯ä¸ªå¥å­æ¯ä¸ªè¯æ˜¯ä»€ä¹ˆç±»åˆ«çš„æ¦‚ç‡å€¼ï¼ˆæ³¨æ„è¿™é‡Œæ²¡æœ‰åš softmaxï¼‰ï¼›
- åˆä¸€ä¸ªå°è£…çš„ç±»ï¼šBertPredictionHeadTransformï¼Œç”¨æ¥å®Œæˆä¸€äº›çº¿æ€§å˜æ¢ï¼š
```
class BertPredictionHeadTransform(nn.Module):
    def __init__(self, config):
        super().__init__()
        self.dense = nn.Linear(config.hidden_size, config.hidden_size)
        if isinstance(config.hidden_act, str):
            self.transform_act_fn = ACT2FN[config.hidden_act]
        else:
            self.transform_act_fn = config.hidden_act
        self.LayerNorm = nn.LayerNorm(config.hidden_size, eps=config.layer_norm_eps)

    def forward(self, hidden_states):
        hidden_states = self.dense(hidden_states)
        hidden_states = self.transform_act_fn(hidden_states)
        hidden_states = self.LayerNorm(hidden_states)
        return hidden_states
```

å›åˆ°`BertForPreTraining`ï¼Œç»§ç»­çœ‹ä¸¤å— `loss` æ˜¯æ€ä¹ˆå¤„ç†çš„ã€‚å®ƒçš„å‰å‘ä¼ æ’­å’ŒBertModelçš„æœ‰æ‰€ä¸åŒï¼Œå¤šäº†`labels`å’Œ`next_sentence_label` ä¸¤ä¸ªè¾“å…¥ï¼š

- labelsï¼šå½¢çŠ¶ä¸º[batch_size, seq_length] ï¼Œä»£è¡¨ MLM ä»»åŠ¡çš„æ ‡ç­¾ï¼Œæ³¨æ„è¿™é‡Œå¯¹äºåŸæœ¬æœªè¢«é®ç›–çš„è¯è®¾ç½®ä¸º -100ï¼Œè¢«é®ç›–è¯æ‰ä¼šæœ‰å®ƒä»¬å¯¹åº”çš„ idï¼Œå’Œä»»åŠ¡è®¾ç½®æ˜¯åè¿‡æ¥çš„ã€‚

  - ä¾‹å¦‚ï¼ŒåŸå§‹å¥å­æ˜¯I want to [MASK] an appleï¼Œè¿™é‡Œæˆ‘æŠŠå•è¯eatç»™é®ä½äº†è¾“å…¥æ¨¡å‹ï¼Œå¯¹åº”çš„labelè®¾ç½®ä¸º[-100, -100, -100, ã€eatå¯¹åº”çš„idã€‘, -100, -100]ï¼›
  - ä¸ºä»€ä¹ˆè¦è®¾ç½®ä¸º -100 è€Œä¸æ˜¯å…¶ä»–æ•°ï¼Ÿå› ä¸ºtorch.nn.CrossEntropyLossé»˜è®¤çš„ignore_index=-100ï¼Œä¹Ÿå°±æ˜¯è¯´å¯¹äºæ ‡ç­¾ä¸º 100 çš„ç±»åˆ«è¾“å…¥ä¸ä¼šè®¡ç®— lossã€‚

- next_sentence_labelï¼šè¿™ä¸€ä¸ªè¾“å…¥å¾ˆç®€å•ï¼Œå°±æ˜¯ 0 å’Œ 1 çš„äºŒåˆ†ç±»æ ‡ç­¾ã€‚

```
# ...
    def forward(
        self,
        input_ids=None,
        attention_mask=None,
        token_type_ids=None,
        position_ids=None,
        head_mask=None,
        inputs_embeds=None,
        labels=None,
        next_sentence_label=None,
        output_attentions=None,
        output_hidden_states=None,
        return_dict=None,
    ): ...
```

æ¥ä¸‹æ¥ä¸¤éƒ¨åˆ† loss çš„ç»„åˆï¼š
```
 # ...
        total_loss = None
        if labels is not None and next_sentence_label is not None:
            loss_fct = CrossEntropyLoss()
            masked_lm_loss = loss_fct(prediction_scores.view(-1, self.config.vocab_size), labels.view(-1))
            next_sentence_loss = loss_fct(seq_relationship_score.view(-1, 2), next_sentence_label.view(-1))
            total_loss = masked_lm_loss + next_sentence_loss
        # ...
```

ç›´æ¥ç›¸åŠ ï¼Œå°±æ˜¯è¿™ä¹ˆå•çº¯çš„ç­–ç•¥ã€‚
å½“ç„¶ï¼Œè¿™ä»½ä»£ç é‡Œé¢ä¹ŸåŒ…å«äº†å¯¹äºåªæƒ³å¯¹å•ä¸ªç›®æ ‡è¿›è¡Œé¢„è®­ç»ƒçš„ BERT æ¨¡å‹ï¼ˆå…·ä½“ç»†èŠ‚ä¸ä½œå±•å¼€ï¼‰ï¼š
- BertForMaskedLMï¼šåªè¿›è¡Œ MLM ä»»åŠ¡çš„é¢„è®­ç»ƒï¼›
  - åŸºäºBertOnlyMLMHeadï¼Œè€Œåè€…ä¹Ÿæ˜¯å¯¹BertLMPredictionHeadçš„å¦ä¸€å±‚å°è£…ï¼›
- BertLMHeadModelï¼šè¿™ä¸ªå’Œä¸Šä¸€ä¸ªçš„åŒºåˆ«åœ¨äºï¼Œè¿™ä¸€æ¨¡å‹æ˜¯ä½œä¸º decoder è¿è¡Œçš„ç‰ˆæœ¬ï¼›
  - åŒæ ·åŸºäºBertOnlyMLMHeadï¼›
- BertForNextSentencePredictionï¼šåªè¿›è¡Œ NSP ä»»åŠ¡çš„é¢„è®­ç»ƒã€‚
  - åŸºäºBertOnlyNSPHeadï¼Œå†…å®¹å°±æ˜¯ä¸€ä¸ªçº¿æ€§å±‚ã€‚


```python
_CHECKPOINT_FOR_DOC = "bert-base-uncased"
_CONFIG_FOR_DOC = "BertConfig"
_TOKENIZER_FOR_DOC = "BertTokenizer"
from transformers.models.bert.modeling_bert import *
from transformers.models.bert.configuration_bert import *
class BertForPreTraining(BertPreTrainedModel):
    def __init__(self, config):
        super().__init__(config)

        self.bert = BertModel(config)
        self.cls = BertPreTrainingHeads(config)

        self.init_weights()

    def get_output_embeddings(self):
        return self.cls.predictions.decoder

    def set_output_embeddings(self, new_embeddings):
        self.cls.predictions.decoder = new_embeddings

    @add_start_docstrings_to_model_forward(BERT_INPUTS_DOCSTRING.format("batch_size, sequence_length"))
    @replace_return_docstrings(output_type=BertForPreTrainingOutput, config_class=_CONFIG_FOR_DOC)
    def forward(
        self,
        input_ids=None,
        attention_mask=None,
        token_type_ids=None,
        position_ids=None,
        head_mask=None,
        inputs_embeds=None,
        labels=None,
        next_sentence_label=None,
        output_attentions=None,
        output_hidden_states=None,
        return_dict=None,
    ):
        r"""
        labels (:obj:`torch.LongTensor` of shape ``(batch_size, sequence_length)``, `optional`):
            Labels for computing the masked language modeling loss. Indices should be in ``[-100, 0, ...,
            config.vocab_size]`` (see ``input_ids`` docstring) Tokens with indices set to ``-100`` are ignored
            (masked), the loss is only computed for the tokens with labels in ``[0, ..., config.vocab_size]``
        next_sentence_label (``torch.LongTensor`` of shape ``(batch_size,)``, `optional`):
            Labels for computing the next sequence prediction (classification) loss. Input should be a sequence pair
            (see :obj:`input_ids` docstring) Indices should be in ``[0, 1]``:
            - 0 indicates sequence B is a continuation of sequence A,
            - 1 indicates sequence B is a random sequence.
        kwargs (:obj:`Dict[str, any]`, optional, defaults to `{}`):
            Used to hide legacy arguments that have been deprecated.
        Returns:
        Example::
from transformers import BertTokenizer, BertForPreTraining
import torch
tokenizer = BertTokenizer.from_pretrained('bert-base-uncased')
model = BertForPreTraining.from_pretrained('bert-base-uncased')
inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")
outputs = model(**inputs)
prediction_logits = outputs.prediction_logits
seq_relationship_logits = outputs.seq_relationship_logits
        """
        return_dict = return_dict if return_dict is not None else self.config.use_return_dict

        outputs = self.bert(
            input_ids,
            attention_mask=attention_mask,
            token_type_ids=token_type_ids,
            position_ids=position_ids,
            head_mask=head_mask,
            inputs_embeds=inputs_embeds,
            output_attentions=output_attentions,
            output_hidden_states=output_hidden_states,
            return_dict=return_dict,
        )

        sequence_output, pooled_output = outputs[:2]
        prediction_scores, seq_relationship_score = self.cls(sequence_output, pooled_output)

        total_loss = None
        if labels is not None and next_sentence_label is not None:
            loss_fct = CrossEntropyLoss()
            masked_lm_loss = loss_fct(prediction_scores.view(-1, self.config.vocab_size), labels.view(-1))
            next_sentence_loss = loss_fct(seq_relationship_score.view(-1, 2), next_sentence_label.view(-1))
            total_loss = masked_lm_loss + next_sentence_loss

        if not return_dict:
            output = (prediction_scores, seq_relationship_score) + outputs[2:]
            return ((total_loss,) + output) if total_loss is not None else output

        return BertForPreTrainingOutput(
            loss=total_loss,
            prediction_logits=prediction_scores,
            seq_relationship_logits=seq_relationship_score,
            hidden_states=outputs.hidden_states,
            attentions=outputs.attentions,
        )

from transformers import BertTokenizer, BertForPreTraining
import torch
tokenizer = BertTokenizer.from_pretrained('bert-base-uncased')
model = BertForPreTraining.from_pretrained('bert-base-uncased')
inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")
outputs = model(**inputs)
prediction_logits = outputs.prediction_logits
seq_relationship_logits = outputs.seq_relationship_logits
```

    Some weights of BertForPreTraining were not initialized from the model checkpoint at bert-base-uncased and are newly initialized: ['cls.predictions.decoder.bias']
    You should probably TRAIN this model on a down-stream task to be able to use it for predictions and inference.



```python
@add_start_docstrings(
    """Bert Model with a `language modeling` head on top for CLM fine-tuning. """, BERT_START_DOCSTRING
)
class BertLMHeadModel(BertPreTrainedModel):

    _keys_to_ignore_on_load_unexpected = [r"pooler"]
    _keys_to_ignore_on_load_missing = [r"position_ids", r"predictions.decoder.bias"]

    def __init__(self, config):
        super().__init__(config)

        if not config.is_decoder:
            logger.warning("If you want to use `BertLMHeadModel` as a standalone, add `is_decoder=True.`")

        self.bert = BertModel(config, add_pooling_layer=False)
        self.cls = BertOnlyMLMHead(config)

        self.init_weights()

    def get_output_embeddings(self):
        return self.cls.predictions.decoder

    def set_output_embeddings(self, new_embeddings):
        self.cls.predictions.decoder = new_embeddings

    @add_start_docstrings_to_model_forward(BERT_INPUTS_DOCSTRING.format("batch_size, sequence_length"))
    @replace_return_docstrings(output_type=CausalLMOutputWithCrossAttentions, config_class=_CONFIG_FOR_DOC)
    def forward(
        self,
        input_ids=None,
        attention_mask=None,
        token_type_ids=None,
        position_ids=None,
        head_mask=None,
        inputs_embeds=None,
        encoder_hidden_states=None,
        encoder_attention_mask=None,
        labels=None,
        past_key_values=None,
        use_cache=None,
        output_attentions=None,
        output_hidden_states=None,
        return_dict=None,
    ):
        r"""
        encoder_hidden_states  (:obj:`torch.FloatTensor` of shape :obj:`(batch_size, sequence_length, hidden_size)`, `optional`):
            Sequence of hidden-states at the output of the last layer of the encoder. Used in the cross-attention if
            the model is configured as a decoder.
        encoder_attention_mask (:obj:`torch.FloatTensor` of shape :obj:`(batch_size, sequence_length)`, `optional`):
            Mask to avoid performing attention on the padding token indices of the encoder input. This mask is used in
            the cross-attention if the model is configured as a decoder. Mask values selected in ``[0, 1]``:
            - 1 for tokens that are **not masked**,
            - 0 for tokens that are **masked**.
        labels (:obj:`torch.LongTensor` of shape :obj:`(batch_size, sequence_length)`, `optional`):
            Labels for computing the left-to-right language modeling loss (next word prediction). Indices should be in
            ``[-100, 0, ..., config.vocab_size]`` (see ``input_ids`` docstring) Tokens with indices set to ``-100`` are
            ignored (masked), the loss is only computed for the tokens with labels n ``[0, ..., config.vocab_size]``
        past_key_values (:obj:`tuple(tuple(torch.FloatTensor))` of length :obj:`config.n_layers` with each tuple having 4 tensors of shape :obj:`(batch_size, num_heads, sequence_length - 1, embed_size_per_head)`):
            Contains precomputed key and value hidden states of the attention blocks. Can be used to speed up decoding.
            If :obj:`past_key_values` are used, the user can optionally input only the last :obj:`decoder_input_ids`
            (those that don't have their past key value states given to this model) of shape :obj:`(batch_size, 1)`
            instead of all :obj:`decoder_input_ids` of shape :obj:`(batch_size, sequence_length)`.
        use_cache (:obj:`bool`, `optional`):
            If set to :obj:`True`, :obj:`past_key_values` key value states are returned and can be used to speed up
            decoding (see :obj:`past_key_values`).
        Returns:
        Example::
            from transformers import BertTokenizer, BertLMHeadModel, BertConfig
            import torch
            tokenizer = BertTokenizer.from_pretrained('bert-base-cased')
            config = BertConfig.from_pretrained("bert-base-cased")
            config.is_decoder = True
            model = BertLMHeadModel.from_pretrained('bert-base-cased', config=config)
            inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")
            outputs = model(**inputs)
            prediction_logits = outputs.logits
        """
        return_dict = return_dict if return_dict is not None else self.config.use_return_dict
        if labels is not None:
            use_cache = False

        outputs = self.bert(
            input_ids,
            attention_mask=attention_mask,
            token_type_ids=token_type_ids,
            position_ids=position_ids,
            head_mask=head_mask,
            inputs_embeds=inputs_embeds,
            encoder_hidden_states=encoder_hidden_states,
            encoder_attention_mask=encoder_attention_mask,
            past_key_values=past_key_values,
            use_cache=use_cache,
            output_attentions=output_attentions,
            output_hidden_states=output_hidden_states,
            return_dict=return_dict,
        )

        sequence_output = outputs[0]
        prediction_scores = self.cls(sequence_output)

        lm_loss = None
        if labels is not None:
            # we are doing next-token prediction; shift prediction scores and input ids by one
            shifted_prediction_scores = prediction_scores[:, :-1, :].contiguous()
            labels = labels[:, 1:].contiguous()
            loss_fct = CrossEntropyLoss()
            lm_loss = loss_fct(shifted_prediction_scores.view(-1, self.config.vocab_size), labels.view(-1))

        if not return_dict:
            output = (prediction_scores,) + outputs[2:]
            return ((lm_loss,) + output) if lm_loss is not None else output

        return CausalLMOutputWithCrossAttentions(
            loss=lm_loss,
            logits=prediction_scores,
            past_key_values=outputs.past_key_values,
            hidden_states=outputs.hidden_states,
            attentions=outputs.attentions,
            cross_attentions=outputs.cross_attentions,
        )

    def prepare_inputs_for_generation(self, input_ids, past=None, attention_mask=None, **model_kwargs):
        input_shape = input_ids.shape
        # if model is used as a decoder in encoder-decoder model, the decoder attention mask is created on the fly
        if attention_mask is None:
            attention_mask = input_ids.new_ones(input_shape)

        # cut decoder_input_ids if past is used
        if past is not None:
            input_ids = input_ids[:, -1:]

        return {"input_ids": input_ids, "attention_mask": attention_mask, "past_key_values": past}

    def _reorder_cache(self, past, beam_idx):
        reordered_past = ()
        for layer_past in past:
            reordered_past += (tuple(past_state.index_select(0, beam_idx) for past_state in layer_past),)
        return reordered_past

from transformers import BertTokenizer, BertLMHeadModel, BertConfig
import torch
tokenizer = BertTokenizer.from_pretrained('bert-base-uncased')
config = BertConfig.from_pretrained("bert-base-uncased")
config.is_decoder = True
model = BertLMHeadModel.from_pretrained('bert-base-uncased', config=config)
inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")
outputs = model(**inputs)
prediction_logits = outputs.logits
```

    Some weights of the model checkpoint at bert-base-uncased were not used when initializing BertLMHeadModel: ['cls.seq_relationship.weight', 'cls.seq_relationship.bias']
    - This IS expected if you are initializing BertLMHeadModel from the checkpoint of a model trained on another task or with another architecture (e.g. initializing a BertForSequenceClassification model from a BertForPreTraining model).
    - This IS NOT expected if you are initializing BertLMHeadModel from the checkpoint of a model that you expect to be exactly identical (initializing a BertForSequenceClassification model from a BertForSequenceClassification model).



```python
class BertForNextSentencePrediction(BertPreTrainedModel):
    def __init__(self, config):
        super().__init__(config)

        self.bert = BertModel(config)
        self.cls = BertOnlyNSPHead(config)

        self.init_weights()

    @add_start_docstrings_to_model_forward(BERT_INPUTS_DOCSTRING.format("batch_size, sequence_length"))
    @replace_return_docstrings(output_type=NextSentencePredictorOutput, config_class=_CONFIG_FOR_DOC)
    def forward(
        self,
        input_ids=None,
        attention_mask=None,
        token_type_ids=None,
        position_ids=None,
        head_mask=None,
        inputs_embeds=None,
        labels=None,
        output_attentions=None,
        output_hidden_states=None,
        return_dict=None,
        **kwargs,
    ):
        r"""
        labels (:obj:`torch.LongTensor` of shape :obj:`(batch_size,)`, `optional`):
            Labels for computing the next sequence prediction (classification) loss. Input should be a sequence pair
            (see ``input_ids`` docstring). Indices should be in ``[0, 1]``:
            - 0 indicates sequence B is a continuation of sequence A,
            - 1 indicates sequence B is a random sequence.
        Returns:
        Example::
from transformers import BertTokenizer, BertForNextSentencePrediction
import torch
tokenizer = BertTokenizer.from_pretrained('bert-base-uncased')
model = BertForNextSentencePrediction.from_pretrained('bert-base-uncased')
prompt = "In Italy, pizza served in formal settings, such as at a restaurant, is presented unsliced."
next_sentence = "The sky is blue due to the shorter wavelength of blue light."
encoding = tokenizer(prompt, next_sentence, return_tensors='pt')
outputs = model(**encoding, labels=torch.LongTensor([1]))
logits = outputs.logits
assert logits[0, 0] < logits[0, 1] # next sentence was random
        """

        if "next_sentence_label" in kwargs:
            warnings.warn(
                "The `next_sentence_label` argument is deprecated and will be removed in a future version, use `labels` instead.",
                FutureWarning,
            )
            labels = kwargs.pop("next_sentence_label")

        return_dict = return_dict if return_dict is not None else self.config.use_return_dict

        outputs = self.bert(
            input_ids,
            attention_mask=attention_mask,
            token_type_ids=token_type_ids,
            position_ids=position_ids,
            head_mask=head_mask,
            inputs_embeds=inputs_embeds,
            output_attentions=output_attentions,
            output_hidden_states=output_hidden_states,
            return_dict=return_dict,
        )

        pooled_output = outputs[1]

        seq_relationship_scores = self.cls(pooled_output)

        next_sentence_loss = None
        if labels is not None:
            loss_fct = CrossEntropyLoss()
            next_sentence_loss = loss_fct(seq_relationship_scores.view(-1, 2), labels.view(-1))

        if not return_dict:
            output = (seq_relationship_scores,) + outputs[2:]
            return ((next_sentence_loss,) + output) if next_sentence_loss is not None else output

        return NextSentencePredictorOutput(
            loss=next_sentence_loss,
            logits=seq_relationship_scores,
            hidden_states=outputs.hidden_states,
            attentions=outputs.attentions,
        )
from transformers import BertTokenizer, BertForNextSentencePrediction
import torch
tokenizer = BertTokenizer.from_pretrained('bert-base-uncased')
model = BertForNextSentencePrediction.from_pretrained('bert-base-uncased')
prompt = "In Italy, pizza served in formal settings, such as at a restaurant, is presented unsliced."
next_sentence = "The sky is blue due to the shorter wavelength of blue light."
encoding = tokenizer(prompt, next_sentence, return_tensors='pt')
outputs = model(**encoding, labels=torch.LongTensor([1]))
logits = outputs.logits
assert logits[0, 0] < logits[0, 1] # next sentence was random
```

    Downloading: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 440M/440M [00:30<00:00, 14.5MB/s]
    Some weights of the model checkpoint at bert-base-uncased were not used when initializing BertForNextSentencePrediction: ['cls.predictions.bias', 'cls.predictions.transform.dense.weight', 'cls.predictions.transform.dense.bias', 'cls.predictions.decoder.weight', 'cls.predictions.transform.LayerNorm.weight', 'cls.predictions.transform.LayerNorm.bias']
    - This IS expected if you are initializing BertForNextSentencePrediction from the checkpoint of a model trained on another task or with another architecture (e.g. initializing a BertForSequenceClassification model from a BertForPreTraining model).
    - This IS NOT expected if you are initializing BertForNextSentencePrediction from the checkpoint of a model that you expect to be exactly identical (initializing a BertForSequenceClassification model from a BertForSequenceClassification model).


æ¥ä¸‹æ¥ä»‹ç»çš„æ˜¯å„ç§ Fine-tune æ¨¡å‹ï¼ŒåŸºæœ¬éƒ½æ˜¯åˆ†ç±»ä»»åŠ¡ï¼š

![Bertï¼šfinetune](./pictures/3-4-bert-ft.png) å›¾ï¼šBertï¼šfinetune

*** 
### 3.2 BertForSequenceClassification
è¿™ä¸€æ¨¡å‹ç”¨äºå¥å­åˆ†ç±»ï¼ˆä¹Ÿå¯ä»¥æ˜¯å›å½’ï¼‰ä»»åŠ¡ï¼Œæ¯”å¦‚ GLUE benchmark çš„å„ä¸ªä»»åŠ¡ã€‚
- å¥å­åˆ†ç±»çš„è¾“å…¥ä¸ºå¥å­ï¼ˆå¯¹ï¼‰ï¼Œè¾“å‡ºä¸ºå•ä¸ªåˆ†ç±»æ ‡ç­¾ã€‚

ç»“æ„ä¸Šå¾ˆç®€å•ï¼Œå°±æ˜¯`BertModel`ï¼ˆæœ‰ poolingï¼‰è¿‡ä¸€ä¸ª dropout åæ¥ä¸€ä¸ªçº¿æ€§å±‚è¾“å‡ºåˆ†ç±»ï¼š
```
class BertForSequenceClassification(BertPreTrainedModel):
    def __init__(self, config):
        super().__init__(config)
        self.num_labels = config.num_labels

        self.bert = BertModel(config)
        self.dropout = nn.Dropout(config.hidden_dropout_prob)
        self.classifier = nn.Linear(config.hidden_size, config.num_labels)

        self.init_weights()
        # ...
```

åœ¨å‰å‘ä¼ æ’­æ—¶ï¼Œå’Œä¸Šé¢é¢„è®­ç»ƒæ¨¡å‹ä¸€æ ·éœ€è¦ä¼ å…¥labelsè¾“å…¥ã€‚

- å¦‚æœåˆå§‹åŒ–çš„num_labels=1ï¼Œé‚£ä¹ˆå°±é»˜è®¤ä¸ºå›å½’ä»»åŠ¡ï¼Œä½¿ç”¨ MSELossï¼›

- å¦åˆ™è®¤ä¸ºæ˜¯åˆ†ç±»ä»»åŠ¡ã€‚


```python
@add_start_docstrings(
    """
    Bert Model transformer with a sequence classification/regression head on top (a linear layer on top of the pooled
    output) e.g. for GLUE tasks.
    """,
    BERT_START_DOCSTRING,
)
class BertForSequenceClassification(BertPreTrainedModel):
    def __init__(self, config):
        super().__init__(config)
        self.num_labels = config.num_labels
        self.config = config

        self.bert = BertModel(config)
        classifier_dropout = (
            config.classifier_dropout if config.classifier_dropout is not None else config.hidden_dropout_prob
        )
        self.dropout = nn.Dropout(classifier_dropout)
        self.classifier = nn.Linear(config.hidden_size, config.num_labels)

        self.init_weights()

    @add_start_docstrings_to_model_forward(BERT_INPUTS_DOCSTRING.format("batch_size, sequence_length"))
    @add_code_sample_docstrings(
        tokenizer_class=_TOKENIZER_FOR_DOC,
        checkpoint=_CHECKPOINT_FOR_DOC,
        output_type=SequenceClassifierOutput,
        config_class=_CONFIG_FOR_DOC,
    )
    def forward(
        self,
        input_ids=None,
        attention_mask=None,
        token_type_ids=None,
        position_ids=None,
        head_mask=None,
        inputs_embeds=None,
        labels=None,
        output_attentions=None,
        output_hidden_states=None,
        return_dict=None,
    ):
        r"""
        labels (:obj:`torch.LongTensor` of shape :obj:`(batch_size,)`, `optional`):
            Labels for computing the sequence classification/regression loss. Indices should be in :obj:`[0, ...,
            config.num_labels - 1]`. If :obj:`config.num_labels == 1` a regression loss is computed (Mean-Square loss),
            If :obj:`config.num_labels > 1` a classification loss is computed (Cross-Entropy).
        """
        return_dict = return_dict if return_dict is not None else self.config.use_return_dict

        outputs = self.bert(
            input_ids,
            attention_mask=attention_mask,
            token_type_ids=token_type_ids,
            position_ids=position_ids,
            head_mask=head_mask,
            inputs_embeds=inputs_embeds,
            output_attentions=output_attentions,
            output_hidden_states=output_hidden_states,
            return_dict=return_dict,
        )

        pooled_output = outputs[1]

        pooled_output = self.dropout(pooled_output)
        logits = self.classifier(pooled_output)

        loss = None
        if labels is not None:
            if self.config.problem_type is None:
                if self.num_labels == 1:
                    self.config.problem_type = "regression"
                elif self.num_labels > 1 and (labels.dtype == torch.long or labels.dtype == torch.int):
                    self.config.problem_type = "single_label_classification"
                else:
                    self.config.problem_type = "multi_label_classification"

            if self.config.problem_type == "regression":
                loss_fct = MSELoss()
                if self.num_labels == 1:
                    loss = loss_fct(logits.squeeze(), labels.squeeze())
                else:
                    loss = loss_fct(logits, labels)
            elif self.config.problem_type == "single_label_classification":
                loss_fct = CrossEntropyLoss()
                loss = loss_fct(logits.view(-1, self.num_labels), labels.view(-1))
            elif self.config.problem_type == "multi_label_classification":
                loss_fct = BCEWithLogitsLoss()
                loss = loss_fct(logits, labels)
        if not return_dict:
            output = (logits,) + outputs[2:]
            return ((loss,) + output) if loss is not None else output

        return SequenceClassifierOutput(
            loss=loss,
            logits=logits,
            hidden_states=outputs.hidden_states,
            attentions=outputs.attentions,
        )
```


```python
from transformers.models.bert.tokenization_bert import BertTokenizer
from transformers.models.bert.modeling_bert import BertForSequenceClassification
tokenizer = BertTokenizer.from_pretrained("bert-base-cased-finetuned-mrpc")
model = BertForSequenceClassification.from_pretrained("bert-base-cased-finetuned-mrpc")

classes = ["not paraphrase", "is paraphrase"]

sequence_0 = "The company HuggingFace is based in New York City"
sequence_1 = "Apples are especially bad for your health"
sequence_2 = "HuggingFace's headquarters are situated in Manhattan"

# The tokekenizer will automatically add any model specific separators (i.e. <CLS> and <SEP>) and tokens to the sequence, as well as compute the attention masks.
paraphrase = tokenizer(sequence_0, sequence_2, return_tensors="pt")
not_paraphrase = tokenizer(sequence_0, sequence_1, return_tensors="pt")

paraphrase_classification_logits = model(**paraphrase).logits
not_paraphrase_classification_logits = model(**not_paraphrase).logits

paraphrase_results = torch.softmax(paraphrase_classification_logits, dim=1).tolist()[0]
not_paraphrase_results = torch.softmax(not_paraphrase_classification_logits, dim=1).tolist()[0]

# Should be paraphrase
for i in range(len(classes)):
    print(f"{classes[i]}: {int(round(paraphrase_results[i] * 100))}%")

# Should not be paraphrase
for i in range(len(classes)):
    print(f"{classes[i]}: {int(round(not_paraphrase_results[i] * 100))}%")
```

    Downloading: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 213k/213k [00:00<00:00, 596kB/s]
    Downloading: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 29.0/29.0 [00:00<00:00, 12.4kB/s]
    Downloading: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 436k/436k [00:00<00:00, 808kB/s]
    Downloading: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 433/433 [00:00<00:00, 166kB/s]
    Downloading: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 433M/433M [00:29<00:00, 14.5MB/s]


    not paraphrase: 10%
    is paraphrase: 90%
    not paraphrase: 94%
    is paraphrase: 6%


*** 
### 3.3 BertForMultipleChoice

è¿™ä¸€æ¨¡å‹ç”¨äºå¤šé¡¹é€‰æ‹©ï¼Œå¦‚ RocStories/SWAG ä»»åŠ¡ã€‚
- å¤šé¡¹é€‰æ‹©ä»»åŠ¡çš„è¾“å…¥ä¸ºä¸€ç»„åˆ†æ¬¡è¾“å…¥çš„å¥å­ï¼Œè¾“å‡ºä¸ºé€‰æ‹©æŸä¸€å¥å­çš„å•ä¸ªæ ‡ç­¾ã€‚
ç»“æ„ä¸Šä¸å¥å­åˆ†ç±»ç›¸ä¼¼ï¼Œåªä¸è¿‡çº¿æ€§å±‚è¾“å‡ºç»´åº¦ä¸º 1ï¼Œå³æ¯æ¬¡éœ€è¦å°†æ¯ä¸ªæ ·æœ¬çš„å¤šä¸ªå¥å­çš„è¾“å‡ºæ‹¼æ¥èµ·æ¥ä½œä¸ºæ¯ä¸ªæ ·æœ¬çš„é¢„æµ‹åˆ†æ•°ã€‚
- å®é™…ä¸Šï¼Œå…·ä½“æ“ä½œæ—¶æ˜¯æŠŠæ¯ä¸ª batch çš„å¤šä¸ªå¥å­ä¸€åŒæ”¾å…¥çš„ï¼Œæ‰€ä»¥ä¸€æ¬¡å¤„ç†çš„è¾“å…¥ä¸º[batch_size, num_choices]æ•°é‡çš„å¥å­ï¼Œå› æ­¤ç›¸åŒ batch å¤§å°æ—¶ï¼Œæ¯”å¥å­åˆ†ç±»ç­‰ä»»åŠ¡éœ€è¦æ›´å¤šçš„æ˜¾å­˜ï¼Œåœ¨è®­ç»ƒæ—¶éœ€è¦å°å¿ƒã€‚

*** 
### 3.4 BertForTokenClassification
è¿™ä¸€æ¨¡å‹ç”¨äºåºåˆ—æ ‡æ³¨ï¼ˆè¯åˆ†ç±»ï¼‰ï¼Œå¦‚ NER ä»»åŠ¡ã€‚
- åºåˆ—æ ‡æ³¨ä»»åŠ¡çš„è¾“å…¥ä¸ºå•ä¸ªå¥å­æ–‡æœ¬ï¼Œè¾“å‡ºä¸ºæ¯ä¸ª token å¯¹åº”çš„ç±»åˆ«æ ‡ç­¾ã€‚
ç”±äºéœ€è¦ç”¨åˆ°æ¯ä¸ª tokenå¯¹åº”çš„è¾“å‡ºè€Œä¸åªæ˜¯æŸå‡ ä¸ªï¼Œæ‰€ä»¥è¿™é‡Œçš„BertModelä¸ç”¨åŠ å…¥ pooling å±‚ï¼›
- åŒæ—¶ï¼Œè¿™é‡Œå°†`_keys_to_ignore_on_load_unexpected`è¿™ä¸€ä¸ªç±»å‚æ•°è®¾ç½®ä¸º`[r"pooler"]`ï¼Œä¹Ÿå°±æ˜¯åœ¨åŠ è½½æ¨¡å‹æ—¶å¯¹äºå‡ºç°ä¸éœ€è¦çš„æƒé‡ä¸å‘ç”ŸæŠ¥é”™ã€‚


```python
class BertForMultipleChoice(BertPreTrainedModel):
    def __init__(self, config):
        super().__init__(config)

        self.bert = BertModel(config)
        self.dropout = nn.Dropout(config.hidden_dropout_prob)
        self.classifier = nn.Linear(config.hidden_size, 1)

        self.init_weights()

    @add_start_docstrings_to_model_forward(BERT_INPUTS_DOCSTRING.format("batch_size, num_choices, sequence_length"))
    @add_code_sample_docstrings(
        tokenizer_class=_TOKENIZER_FOR_DOC,
        checkpoint=_CHECKPOINT_FOR_DOC,
        output_type=MultipleChoiceModelOutput,
        config_class=_CONFIG_FOR_DOC,
    )
    def forward(
        self,
        input_ids=None,
        attention_mask=None,
        token_type_ids=None,
        position_ids=None,
        head_mask=None,
        inputs_embeds=None,
        labels=None,
        output_attentions=None,
        output_hidden_states=None,
        return_dict=None,
    ):
        r"""
        labels (:obj:`torch.LongTensor` of shape :obj:`(batch_size,)`, `optional`):
            Labels for computing the multiple choice classification loss. Indices should be in ``[0, ...,
            num_choices-1]`` where :obj:`num_choices` is the size of the second dimension of the input tensors. (See
            :obj:`input_ids` above)
        """
        return_dict = return_dict if return_dict is not None else self.config.use_return_dict
        num_choices = input_ids.shape[1] if input_ids is not None else inputs_embeds.shape[1]

        input_ids = input_ids.view(-1, input_ids.size(-1)) if input_ids is not None else None
        attention_mask = attention_mask.view(-1, attention_mask.size(-1)) if attention_mask is not None else None
        token_type_ids = token_type_ids.view(-1, token_type_ids.size(-1)) if token_type_ids is not None else None
        position_ids = position_ids.view(-1, position_ids.size(-1)) if position_ids is not None else None
        inputs_embeds = (
            inputs_embeds.view(-1, inputs_embeds.size(-2), inputs_embeds.size(-1))
            if inputs_embeds is not None
            else None
        )

        outputs = self.bert(
            input_ids,
            attention_mask=attention_mask,
            token_type_ids=token_type_ids,
            position_ids=position_ids,
            head_mask=head_mask,
            inputs_embeds=inputs_embeds,
            output_attentions=output_attentions,
            output_hidden_states=output_hidden_states,
            return_dict=return_dict,
        )

        pooled_output = outputs[1]

        pooled_output = self.dropout(pooled_output)
        logits = self.classifier(pooled_output)
        reshaped_logits = logits.view(-1, num_choices)

        loss = None
        if labels is not None:
            loss_fct = CrossEntropyLoss()
            loss = loss_fct(reshaped_logits, labels)

        if not return_dict:
            output = (reshaped_logits,) + outputs[2:]
            return ((loss,) + output) if loss is not None else output

        return MultipleChoiceModelOutput(
            loss=loss,
            logits=reshaped_logits,
            hidden_states=outputs.hidden_states,
            attentions=outputs.attentions,
        )

```


```python
@add_start_docstrings(
    """
    Bert Model with a token classification head on top (a linear layer on top of the hidden-states output) e.g. for
    Named-Entity-Recognition (NER) tasks.
    """,
    BERT_START_DOCSTRING,
)
class BertForTokenClassification(BertPreTrainedModel):

    _keys_to_ignore_on_load_unexpected = [r"pooler"]

    def __init__(self, config):
        super().__init__(config)
        self.num_labels = config.num_labels

        self.bert = BertModel(config, add_pooling_layer=False)
        classifier_dropout = (
            config.classifier_dropout if config.classifier_dropout is not None else config.hidden_dropout_prob
        )
        self.dropout = nn.Dropout(classifier_dropout)
        self.classifier = nn.Linear(config.hidden_size, config.num_labels)

        self.init_weights()

    @add_start_docstrings_to_model_forward(BERT_INPUTS_DOCSTRING.format("batch_size, sequence_length"))
    @add_code_sample_docstrings(
        tokenizer_class=_TOKENIZER_FOR_DOC,
        checkpoint=_CHECKPOINT_FOR_DOC,
        output_type=TokenClassifierOutput,
        config_class=_CONFIG_FOR_DOC,
    )
    def forward(
        self,
        input_ids=None,
        attention_mask=None,
        token_type_ids=None,
        position_ids=None,
        head_mask=None,
        inputs_embeds=None,
        labels=None,
        output_attentions=None,
        output_hidden_states=None,
        return_dict=None,
    ):
        r"""
        labels (:obj:`torch.LongTensor` of shape :obj:`(batch_size, sequence_length)`, `optional`):
            Labels for computing the token classification loss. Indices should be in ``[0, ..., config.num_labels -
            1]``.
        """
        return_dict = return_dict if return_dict is not None else self.config.use_return_dict

        outputs = self.bert(
            input_ids,
            attention_mask=attention_mask,
            token_type_ids=token_type_ids,
            position_ids=position_ids,
            head_mask=head_mask,
            inputs_embeds=inputs_embeds,
            output_attentions=output_attentions,
            output_hidden_states=output_hidden_states,
            return_dict=return_dict,
        )

        sequence_output = outputs[0]

        sequence_output = self.dropout(sequence_output)
        logits = self.classifier(sequence_output)

        loss = None
        if labels is not None:
            loss_fct = CrossEntropyLoss()
            # Only keep active parts of the loss
            if attention_mask is not None:
                active_loss = attention_mask.view(-1) == 1
                active_logits = logits.view(-1, self.num_labels)
                active_labels = torch.where(
                    active_loss, labels.view(-1), torch.tensor(loss_fct.ignore_index).type_as(labels)
                )
                loss = loss_fct(active_logits, active_labels)
            else:
                loss = loss_fct(logits.view(-1, self.num_labels), labels.view(-1))

        if not return_dict:
            output = (logits,) + outputs[2:]
            return ((loss,) + output) if loss is not None else output

        return TokenClassifierOutput(
            loss=loss,
            logits=logits,
            hidden_states=outputs.hidden_states,
            attentions=outputs.attentions,
        )

```


```python
from transformers import BertForTokenClassification, BertTokenizer
import torch

model = BertForTokenClassification.from_pretrained("dbmdz/bert-large-cased-finetuned-conll03-english")
tokenizer = BertTokenizer.from_pretrained("bert-base-cased")

label_list = [
"O",       # Outside of a named entity
"B-MISC",  # Beginning of a miscellaneous entity right after another miscellaneous entity
"I-MISC",  # Miscellaneous entity
"B-PER",   # Beginning of a person's name right after another person's name
"I-PER",   # Person's name
"B-ORG",   # Beginning of an organisation right after another organisation
"I-ORG",   # Organisation
"B-LOC",   # Beginning of a location right after another location
"I-LOC"    # Location
]

sequence = "Hugging Face Inc. is a company based in New York City. Its headquarters are in DUMBO, therefore very close to the Manhattan Bridge."

# Bit of a hack to get the tokens with the special tokens
tokens = tokenizer.tokenize(tokenizer.decode(tokenizer.encode(sequence)))
inputs = tokenizer.encode(sequence, return_tensors="pt")

outputs = model(inputs).logits
predictions = torch.argmax(outputs, dim=2)
```

    Downloading: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 998/998 [00:00<00:00, 382kB/s]
    Downloading: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 1.33G/1.33G [01:30<00:00, 14.7MB/s]



```python
for token, prediction in zip(tokens, predictions[0].numpy()):
    print((token, model.config.id2label[prediction]))
```

    ('[CLS]', 'O')
    ('Hu', 'I-ORG')
    ('##gging', 'I-ORG')
    ('Face', 'I-ORG')
    ('Inc', 'I-ORG')
    ('.', 'O')
    ('is', 'O')
    ('a', 'O')
    ('company', 'O')
    ('based', 'O')
    ('in', 'O')
    ('New', 'I-LOC')
    ('York', 'I-LOC')
    ('City', 'I-LOC')
    ('.', 'O')
    ('Its', 'O')
    ('headquarters', 'O')
    ('are', 'O')
    ('in', 'O')
    ('D', 'I-LOC')
    ('##UM', 'I-LOC')
    ('##BO', 'I-LOC')
    (',', 'O')
    ('therefore', 'O')
    ('very', 'O')
    ('close', 'O')
    ('to', 'O')
    ('the', 'O')
    ('Manhattan', 'I-LOC')
    ('Bridge', 'I-LOC')
    ('.', 'O')
    ('[SEP]', 'O')


*** 
### 3.5 BertForQuestionAnswering
è¿™ä¸€æ¨¡å‹ç”¨äºè§£å†³é—®ç­”ä»»åŠ¡ï¼Œä¾‹å¦‚ SQuAD ä»»åŠ¡ã€‚
- é—®ç­”ä»»åŠ¡çš„è¾“å…¥ä¸ºé—®é¢˜ +ï¼ˆå¯¹äº BERT åªèƒ½æ˜¯ä¸€ä¸ªï¼‰å›ç­”ç»„æˆçš„å¥å­å¯¹ï¼Œè¾“å‡ºä¸ºèµ·å§‹ä½ç½®å’Œç»“æŸä½ç½®ç”¨äºæ ‡å‡ºå›ç­”ä¸­çš„å…·ä½“æ–‡æœ¬ã€‚
è¿™é‡Œéœ€è¦ä¸¤ä¸ªè¾“å‡ºï¼Œå³å¯¹èµ·å§‹ä½ç½®çš„é¢„æµ‹å’Œå¯¹ç»“æŸä½ç½®çš„é¢„æµ‹ï¼Œä¸¤ä¸ªè¾“å‡ºçš„é•¿åº¦éƒ½å’Œå¥å­é•¿åº¦ä¸€æ ·ï¼Œä»å…¶ä¸­æŒ‘å‡ºæœ€å¤§çš„é¢„æµ‹å€¼å¯¹åº”çš„ä¸‹æ ‡ä½œä¸ºé¢„æµ‹çš„ä½ç½®ã€‚
- å¯¹è¶…å‡ºå¥å­é•¿åº¦çš„éæ³• labelï¼Œä¼šå°†å…¶å‹ç¼©ï¼ˆtorch.clamp_ï¼‰åˆ°åˆç†èŒƒå›´ã€‚

ä»¥ä¸Šå°±æ˜¯å…³äº BERT æºç çš„ä»‹ç»ï¼Œä¸‹é¢ä»‹ç»ä¸€äº›å…³äº BERT æ¨¡å‹å®ç”¨çš„è®­ç»ƒç»†èŠ‚ã€‚


```python
@add_start_docstrings(
    """
    Bert Model with a span classification head on top for extractive question-answering tasks like SQuAD (a linear
    layers on top of the hidden-states output to compute `span start logits` and `span end logits`).
    """,
    BERT_START_DOCSTRING,
)
class BertForQuestionAnswering(BertPreTrainedModel):

    _keys_to_ignore_on_load_unexpected = [r"pooler"]

    def __init__(self, config):
        super().__init__(config)
        self.num_labels = config.num_labels

        self.bert = BertModel(config, add_pooling_layer=False)
        self.qa_outputs = nn.Linear(config.hidden_size, config.num_labels)

        self.init_weights()

    @add_start_docstrings_to_model_forward(BERT_INPUTS_DOCSTRING.format("batch_size, sequence_length"))
    @add_code_sample_docstrings(
        tokenizer_class=_TOKENIZER_FOR_DOC,
        checkpoint=_CHECKPOINT_FOR_DOC,
        output_type=QuestionAnsweringModelOutput,
        config_class=_CONFIG_FOR_DOC,
    )
    def forward(
        self,
        input_ids=None,
        attention_mask=None,
        token_type_ids=None,
        position_ids=None,
        head_mask=None,
        inputs_embeds=None,
        start_positions=None,
        end_positions=None,
        output_attentions=None,
        output_hidden_states=None,
        return_dict=None,
    ):
        r"""
        start_positions (:obj:`torch.LongTensor` of shape :obj:`(batch_size,)`, `optional`):
            Labels for position (index) of the start of the labelled span for computing the token classification loss.
            Positions are clamped to the length of the sequence (:obj:`sequence_length`). Position outside of the
            sequence are not taken into account for computing the loss.
        end_positions (:obj:`torch.LongTensor` of shape :obj:`(batch_size,)`, `optional`):
            Labels for position (index) of the end of the labelled span for computing the token classification loss.
            Positions are clamped to the length of the sequence (:obj:`sequence_length`). Position outside of the
            sequence are not taken into account for computing the loss.
        """
        return_dict = return_dict if return_dict is not None else self.config.use_return_dict

        outputs = self.bert(
            input_ids,
            attention_mask=attention_mask,
            token_type_ids=token_type_ids,
            position_ids=position_ids,
            head_mask=head_mask,
            inputs_embeds=inputs_embeds,
            output_attentions=output_attentions,
            output_hidden_states=output_hidden_states,
            return_dict=return_dict,
        )

        sequence_output = outputs[0]

        logits = self.qa_outputs(sequence_output)
        start_logits, end_logits = logits.split(1, dim=-1)
        start_logits = start_logits.squeeze(-1).contiguous()
        end_logits = end_logits.squeeze(-1).contiguous()

        total_loss = None
        if start_positions is not None and end_positions is not None:
            # If we are on multi-GPU, split add a dimension
            if len(start_positions.size()) > 1:
                start_positions = start_positions.squeeze(-1)
            if len(end_positions.size()) > 1:
                end_positions = end_positions.squeeze(-1)
            # sometimes the start/end positions are outside our model inputs, we ignore these terms
            ignored_index = start_logits.size(1)
            start_positions = start_positions.clamp(0, ignored_index)
            end_positions = end_positions.clamp(0, ignored_index)

            loss_fct = CrossEntropyLoss(ignore_index=ignored_index)
            start_loss = loss_fct(start_logits, start_positions)
            end_loss = loss_fct(end_logits, end_positions)
            total_loss = (start_loss + end_loss) / 2

        if not return_dict:
            output = (start_logits, end_logits) + outputs[2:]
            return ((total_loss,) + output) if total_loss is not None else output

        return QuestionAnsweringModelOutput(
            loss=total_loss,
            start_logits=start_logits,
            end_logits=end_logits,
            hidden_states=outputs.hidden_states,
            attentions=outputs.attentions,
        )

```


```python
from transformers import AutoTokenizer, AutoModelForQuestionAnswering
import torch

tokenizer = AutoTokenizer.from_pretrained("bert-large-uncased-whole-word-masking-finetuned-squad")
model = AutoModelForQuestionAnswering.from_pretrained("bert-large-uncased-whole-word-masking-finetuned-squad")

text = "ğŸ¤— Transformers (formerly known as pytorch-transformers and pytorch-pretrained-bert) provides general-purpose architectures (BERT, GPT-2, RoBERTa, XLM, DistilBert, XLNetâ€¦) for Natural Language Understanding (NLU) and Natural Language Generation (NLG) with over 32+ pretrained models in 100+ languages and deep interoperability between TensorFlow 2.0 and PyTorch."

questions = [
"How many pretrained models are available in ğŸ¤— Transformers?",
"What does ğŸ¤— Transformers provide?",
"ğŸ¤— Transformers provides interoperability between which frameworks?",
]

for question in questions:
    inputs = tokenizer(question, text, add_special_tokens=True, return_tensors="pt")
    input_ids = inputs["input_ids"].tolist()[0]
    outputs = model(**inputs)
    answer_start_scores = outputs.start_logits
    answer_end_scores = outputs.end_logits
    answer_start = torch.argmax(
        answer_start_scores
    )  # Get the most likely beginning of answer with the argmax of the score
    answer_end = torch.argmax(answer_end_scores) + 1  # Get the most likely end of answer with the argmax of the score
    answer = tokenizer.convert_tokens_to_string(tokenizer.convert_ids_to_tokens(input_ids[answer_start:answer_end]))
    print(f"Question: {question}")
    print(f"Answer: {answer}")
```

    Downloading: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 443/443 [00:00<00:00, 186kB/s]
    Downloading: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 232k/232k [00:00<00:00, 438kB/s]
    Downloading: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 466k/466k [00:00<00:00, 845kB/s]
    Downloading: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 28.0/28.0 [00:00<00:00, 10.5kB/s]
    Downloading: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 1.34G/1.34G [01:28<00:00, 15.1MB/s]


    Question: How many pretrained models are available in ğŸ¤— Transformers?
    Answer: over 32 +
    Question: What does ğŸ¤— Transformers provide?
    Answer: general - purpose architectures
    Question: ğŸ¤— Transformers provides interoperability between which frameworks?
    Answer: tensorflow 2. 0 and pytorch


*** 
## BERTè®­ç»ƒå’Œä¼˜åŒ–
### 4.1 Pre-Training
é¢„è®­ç»ƒé˜¶æ®µï¼Œé™¤äº†ä¼—æ‰€å‘¨çŸ¥çš„ 15%ã€80% mask æ¯”ä¾‹ï¼Œæœ‰ä¸€ä¸ªå€¼å¾—æ³¨æ„çš„åœ°æ–¹å°±æ˜¯å‚æ•°å…±äº«ã€‚
ä¸æ­¢ BERTï¼Œæ‰€æœ‰ huggingface å®ç°çš„ PLM çš„ word embedding å’Œ masked language model çš„é¢„æµ‹æƒé‡åœ¨åˆå§‹åŒ–è¿‡ç¨‹ä¸­éƒ½æ˜¯å…±äº«çš„ï¼š
```
class PreTrainedModel(nn.Module, ModuleUtilsMixin, GenerationMixin):
    # ...
    def tie_weights(self):
        """
        Tie the weights between the input embeddings and the output embeddings.

        If the :obj:`torchscript` flag is set in the configuration, can't handle parameter sharing so we are cloning
        the weights instead.
        """
        output_embeddings = self.get_output_embeddings()
        if output_embeddings is not None and self.config.tie_word_embeddings:
            self._tie_or_clone_weights(output_embeddings, self.get_input_embeddings())

        if self.config.is_encoder_decoder and self.config.tie_encoder_decoder:
            if hasattr(self, self.base_model_prefix):
                self = getattr(self, self.base_model_prefix)
            self._tie_encoder_decoder_weights(self.encoder, self.decoder, self.base_model_prefix)
    # ...
```

è‡³äºä¸ºä»€ä¹ˆï¼Œåº”è¯¥æ˜¯å› ä¸º word_embedding å’Œ prediction æƒé‡å¤ªå¤§äº†ï¼Œä»¥ bert-base ä¸ºä¾‹ï¼Œå…¶å°ºå¯¸ä¸º(30522, 768)ï¼Œé™ä½è®­ç»ƒéš¾åº¦ã€‚


***
### 4.2 Fine-Tuning
å¾®è°ƒä¹Ÿå°±æ˜¯ä¸‹æ¸¸ä»»åŠ¡é˜¶æ®µï¼Œä¹Ÿæœ‰ä¸¤ä¸ªå€¼å¾—æ³¨æ„çš„åœ°æ–¹ã€‚
#### 4.2.1 AdamW
é¦–å…ˆä»‹ç»ä¸€ä¸‹ BERT çš„ä¼˜åŒ–å™¨ï¼šAdamWï¼ˆAdamWeightDecayOptimizerï¼‰ã€‚

è¿™ä¸€ä¼˜åŒ–å™¨æ¥è‡ª ICLR 2017 çš„ Best Paperï¼šã€ŠFixing Weight Decay Regularization in Adamã€‹ä¸­æå‡ºçš„ä¸€ç§ç”¨äºä¿®å¤ Adam çš„æƒé‡è¡°å‡é”™è¯¯çš„æ–°æ–¹æ³•ã€‚è®ºæ–‡æŒ‡å‡ºï¼ŒL2 æ­£åˆ™åŒ–å’Œæƒé‡è¡°å‡åœ¨å¤§éƒ¨åˆ†æƒ…å†µä¸‹å¹¶ä¸ç­‰ä»·ï¼Œåªåœ¨ SGD ä¼˜åŒ–çš„æƒ…å†µä¸‹æ˜¯ç­‰ä»·çš„ï¼›è€Œå¤§å¤šæ•°æ¡†æ¶ä¸­å¯¹äº Adam+L2 æ­£åˆ™ä½¿ç”¨çš„æ˜¯æƒé‡è¡°å‡çš„æ–¹å¼ï¼Œä¸¤è€…ä¸èƒ½æ··ä¸ºä¸€è°ˆã€‚

AdamW æ˜¯åœ¨ Adam+L2 æ­£åˆ™åŒ–çš„åŸºç¡€ä¸Šè¿›è¡Œæ”¹è¿›çš„ç®—æ³•ï¼Œä¸ä¸€èˆ¬çš„ Adam+L2 çš„åŒºåˆ«å¦‚ä¸‹ï¼š

![å›¾ï¼šAdamW](./pictures/3-5-adamw.png) å›¾ï¼šAdamW

å…³äº AdamW çš„åˆ†æå¯ä»¥å‚è€ƒï¼š

- AdamW and Super-convergence is now the fastest way to train neural nets [1]
- paperplanetï¼šéƒ½ 9102 å¹´äº†ï¼Œåˆ«å†ç”¨ Adam + L2 regularizationäº† [2]

é€šå¸¸ï¼Œæˆ‘ä»¬ä¼šé€‰æ‹©æ¨¡å‹çš„ weight éƒ¨åˆ†å‚ä¸ decay è¿‡ç¨‹ï¼Œè€Œå¦ä¸€éƒ¨åˆ†ï¼ˆåŒ…æ‹¬ LayerNorm çš„ weightï¼‰ä¸å‚ä¸ï¼ˆä»£ç æœ€åˆæ¥æºåº”è¯¥æ˜¯ Huggingface çš„ç¤ºä¾‹ï¼‰
è¡¥å……ï¼šå…³äºè¿™ä¹ˆåšçš„ç†ç”±ï¼Œæˆ‘æš‚æ—¶æ²¡æœ‰æ‰¾åˆ°åˆç†çš„è§£ç­”ã€‚

```
# model: a Bert-based-model object
    # learning_rate: default 2e-5 for text classification
    param_optimizer = list(model.named_parameters())
    no_decay = ['bias', 'LayerNorm.bias', 'LayerNorm.weight']
    optimizer_grouped_parameters = [
        {'params': [p for n, p in param_optimizer if not any(
            nd in n for nd in no_decay)], 'weight_decay': 0.01},
        {'params': [p for n, p in param_optimizer if any(
            nd in n for nd in no_decay)], 'weight_decay': 0.0}
    ]
    optimizer = AdamW(optimizer_grouped_parameters,
                      lr=learning_rate)
    # ...
```

#### 4.2.2 Warmup

BERT çš„è®­ç»ƒä¸­å¦ä¸€ä¸ªç‰¹ç‚¹åœ¨äº Warmupï¼Œå…¶å«ä¹‰ä¸ºï¼š

åœ¨è®­ç»ƒåˆæœŸä½¿ç”¨è¾ƒå°çš„å­¦ä¹ ç‡ï¼ˆä» 0 å¼€å§‹ï¼‰ï¼Œåœ¨ä¸€å®šæ­¥æ•°ï¼ˆæ¯”å¦‚ 1000 æ­¥ï¼‰å†…é€æ¸æé«˜åˆ°æ­£å¸¸å¤§å°ï¼ˆæ¯”å¦‚ä¸Šé¢çš„ 2e-5ï¼‰ï¼Œé¿å…æ¨¡å‹è¿‡æ—©è¿›å…¥å±€éƒ¨æœ€ä¼˜è€Œè¿‡æ‹Ÿåˆï¼›
- åœ¨è®­ç»ƒåæœŸå†æ…¢æ…¢å°†å­¦ä¹ ç‡é™ä½åˆ° 0ï¼Œé¿å…åæœŸè®­ç»ƒè¿˜å‡ºç°è¾ƒå¤§çš„å‚æ•°å˜åŒ–ã€‚
- åœ¨ Huggingface çš„å®ç°ä¸­ï¼Œå¯ä»¥ä½¿ç”¨å¤šç§ warmup ç­–ç•¥ï¼š
```
TYPE_TO_SCHEDULER_FUNCTION = {
    SchedulerType.LINEAR: get_linear_schedule_with_warmup,
    SchedulerType.COSINE: get_cosine_schedule_with_warmup,
    SchedulerType.COSINE_WITH_RESTARTS: get_cosine_with_hard_restarts_schedule_with_warmup,
    SchedulerType.POLYNOMIAL: get_polynomial_decay_schedule_with_warmup,
    SchedulerType.CONSTANT: get_constant_schedule,
    SchedulerType.CONSTANT_WITH_WARMUP: get_constant_schedule_with_warmup,
}
```
å…·ä½“è€Œè¨€ï¼š
- CONSTANTï¼šä¿æŒå›ºå®šå­¦ä¹ ç‡ä¸å˜ï¼›
- CONSTANT_WITH_WARMUPï¼šåœ¨æ¯ä¸€ä¸ª step ä¸­çº¿æ€§è°ƒæ•´å­¦ä¹ ç‡ï¼›
- LINEARï¼šä¸Šæ–‡æåˆ°çš„ä¸¤æ®µå¼è°ƒæ•´ï¼›
- COSINEï¼šå’Œä¸¤æ®µå¼è°ƒæ•´ç±»ä¼¼ï¼Œåªä¸è¿‡é‡‡ç”¨çš„æ˜¯ä¸‰è§’å‡½æ•°å¼çš„æ›²çº¿è°ƒæ•´ï¼›
- COSINE_WITH_RESTARTSï¼šè®­ç»ƒä¸­å°†ä¸Šé¢ COSINE çš„è°ƒæ•´é‡å¤ n æ¬¡ï¼›
- POLYNOMIALï¼šæŒ‰æŒ‡æ•°æ›²çº¿è¿›è¡Œä¸¤æ®µå¼è°ƒæ•´ã€‚
å…·ä½“ä½¿ç”¨å‚è€ƒtransformers/optimization.pyï¼š
æœ€å¸¸ç”¨çš„è¿˜æ˜¯get_linear_scheduler_with_warmupå³çº¿æ€§ä¸¤æ®µå¼è°ƒæ•´å­¦ä¹ ç‡çš„æ–¹æ¡ˆã€‚

```
def get_scheduler(
    name: Union[str, SchedulerType],
    optimizer: Optimizer,
    num_warmup_steps: Optional[int] = None,
    num_training_steps: Optional[int] = None,
): ...

```

ä»¥ä¸Šå³ä¸ºå…³äº transformers åº“ï¼ˆ4.4.2 ç‰ˆæœ¬ï¼‰ä¸­ BERT åº”ç”¨çš„ç›¸å…³ä»£ç çš„å…·ä½“å®ç°åˆ†æï¼Œæ¬¢è¿ä¸è¯»è€…å…±åŒäº¤æµæ¢è®¨ã€‚

## è‡´è°¢
æœ¬æ–‡ä¸»è¦ç”±æµ™æ±Ÿå¤§å­¦ææ³ºç§‹æ’°å†™ï¼Œæœ¬é¡¹ç›®åŒå­¦è´Ÿè´£æ•´ç†å’Œæ±‡æ€»ã€‚


```python

```
